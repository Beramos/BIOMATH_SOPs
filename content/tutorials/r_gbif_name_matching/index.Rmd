---
title: "Match scientific names with the GBIF Backbone Taxonomy"
author: "Dirk Maes, Dimitri Brosens, Damiano Oldoni"
date: 2018-06-14
categories: ["r"]
tags: ["api", "webservice", "r", "gbif", "biodiversity"]
output: 
    md_document:
        preserve_yaml: true
        variant: markdown_github
---

## Introduction

This tutorial will explain how you can match a list of _scientific names_ against the [GBIF backbone taxonomy](https://www.gbif.org/dataset/d7dddbf4-2cf0-4f39-9b2a-bb099caae36c).

Important is that you have the most recent version of [inborutils](https://inbo.github.io/inborutils/) installed and available:

```{r install_pkgs, eval=FALSE}
devtools::install_github("inbo/inboruilts")   # install inboruilts
```

```{r load_libraries, message=FALSE, warning=FALSE}
library(tidyverse)    # To do datascience
library(rgbif)        # To lookup names in the GBIF backbone taxonomy
library(inborutils)   # To wrap GBIF API data
library(knitr)
```

## Read data file containing the scientific names

Read file containing the scientific names you want to check against the [GBIF](https://www.gbif.org/species/search?q=) taxonomic backbone:

```{r read_species_list}
species_list <- read_csv("https://raw.githubusercontent.com/inbo/inbo-pyutils/master/gbif/gbif_name_match/sample.csv", trim_ws = TRUE, col_types = cols())
```
   
Take a look at the data:

```{r preview_species_list}
knitr::kable(species_list)
```

## Request taxonomic information

Match the column containing the scientific name with GBIF, using the `gbif_species_name_match` function from the [inborutils](https://inbo.github.io/inborutils/reference/gbif_species_name_match.html) package:

```{r, message=FALSE, warning=FALSE}
species_list_matched <- species_list %>% 
    gbif_species_name_match(name = "name") 
```

The `name` argument is the column name containing the scientific names. Default value: `name`. So, the code above is equivalent to:

```{r similar_code, eval=FALSE}
species_list_matched <- species_list %>% 
    gbif_species_name_match() 
```

By default, `gbif_species_name_match` returns the following GBIF fields: `usageKey`, `scientificName`, `rank`, `order`, `matchType`, `phylum`, `kingdom`, `genus`, `class`, `confidence`, `synonym`, `status`, `family`.

Take a look at the updated data:

```{r view_output}
knitr::kable(species_list_matched)
```

Notice that GBIF fields whose name is already used as column name are automatically renamed by adding suffix  `1`. In our case, input data.frame `species_list` contains already a column called `kingdom`: the GBIF kingdom values are returned in column `kingdom1`:

```{r zoom_kingdom}
species_list_matched %>% select(kingdom, kingdom1)
```

You can specify which GBIF fields you would like to have:

```{r, message=FALSE, warning=FALSE}
species_list %>% 
    gbif_species_name_match(
      gbif_terms = c(
        'scientificName', 
        'family',
        'order',
        'rank',
        'matchType',
        'confidence',
        'status')) %>%
    kable()
```

As `gbif_species_name_match` is a wrapper around rgbif function `name_backbone`, the authors thought important to offer the possibility to pass any parameter of rgbif function `name_backbone`. So, for example, you can set `strict = TRUE` to fuzzy match only the given names, but never a taxon in the upper classification:

```{r example_strict, message=FALSE, warning=FALSE}
species_list %>% 
    gbif_species_name_match(strict = TRUE) %>%
    kable()
```

All accepted parameters of `name_backbone`: 'rank', 'kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'strict', 'verbose', 'start', 'limit', 'curlopts'. See `?name_backbone` for more details.

For Python users, there is a similar (but no longer maintained) [function](https://github.com/inbo/inbo-pyutils/tree/master/gbif/gbif_name_match) in `inbo-pyutils`.
